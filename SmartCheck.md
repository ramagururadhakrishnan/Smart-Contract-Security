|  S.NO |  Rule |  Description  |   
|:-------:|---------|------------|
|  1 | SOLIDITY_ADDRESS_HARDCODED | The contract contains unknown address. This address might be used for some malicious activity. Please check hardcoded address and it's usage.| 
|  2 | SOLIDITY_ARRAY_LENGTH_MANIPULATION |The length of the dynamic array is changed directly. In this case, the appearance of gigantic arrays is possible and it can lead to a storage overlap attack (collisions with other data in storage)| 
|  3 | SOLIDITY_BALANCE_EQUALITY| The balance is checked for strict equality.Avoid checking for strict balance equality:an adversary can forcibly send ether to any address via selfdestruct() or by mining.| 
|  4 | SOLIDITY_BYTE_ARRAY_INSTEAD_BYTES | lower gas consumption  | 
|  5 | SOLIDITY_CALL_WITHOUT_DATA | Use of low-level code call  function with no arguments provided.| 
|  6 | SOLIDITY_CONSTRUCTOR_RETURN  | Statement is used in contract's constructor. With code return the process of deploy will differ from the intuitive one. For instance, deployed bytecode may not include functions implemented in the source.| 
|  7 | SOLIDITY_DELETE_ON_DYNAMIC_ARRAYS|  Applying delete</code> or <code>.length = 0</code> to dynamically-sized storage arrays may lead to Out-of-Gas exception.  | 
|  8 | SOLIDITY_DEPRECATED_CONSTRUCTIONS  | Deprecated constructions| 
|  9 | SOLIDITY_DIV_MUL | Solidity operates only with integers. Thus, if the division is done before the  multiplication,the rounding errors can increase dramatically.| 
|  10 |SOLIDITY_DO_WHILE_CONTINUE  | Prior to version 0.5.0, Solidity compiler handles code inside do-while loop incorrectly it will ignores code while condition. | 
|  11 |SOLIDITY_EXACT_TIME  | Strict comparison with block,timestamp.Miners can affect code block.timestamp code for their benefits. Thus, one should not rely on the exact value of code block,timestamp code | 
|  12 | SOLIDITY_EXTRA_GAS_IN_LOOPS|State variable,code balance length code of non-memory array is used in the condition of code while loop. In this case, every iteration of loop consumes extra gas. | 
|  13 |SOLIDITY_FUNCTION_RETURNS_TYPE_AND_NO_RETURN  | Function doesn't initialize return value. As result default value will be returned.| 
|  14 |SOLIDITY_GAS_LIMIT_IN_LOOPS  |Ethereum is a very resource-constrained environment. Prices per computational step are orders of magnitude higher than with centralized providers. Moreover, Ethereum miners impose a limit on the total number of gas consumed in a block. If code array,length code is large enough, the function exceeds the block gas limit, and transactions calling it will never be confirmed|
|  15 |SOLIDITY_INCORRECT_BLOCKHASH|Blockhash function returns a non-zero value only for 256 last blocks. Besides, it always returns 0 for the current block, i.e.blockhash(block.number) always equals to 0|
|  16 | SOLIDITY_LOCKED_MONEY | Contracts programmed to receive ether should implement a way to withdraw it, i.e., call transfer code(recommended),code send , call.value code at least once.| 
|  17 | SOLIDITY_MSGVALUE_EQUALS_ZERO | The code msg.value == 0 condition check is meaningless in most cases.| 
|  18 |SOLIDITY_OVERPOWERED_ROLE  | This function is callable only from one address.Therefore, the system depends heavily on this address. In this case, there are scenarios that may lead to undesirable consequences for investors, e.g. if the private key of this address becomes compromised.|
|  19 | SOLIDITY_PRAGMAS_VERSION  | pragma solidity ^0.4.17; // bad: compiles w 0.4.17 and pragma solidity 0.4.24; // good : compiles w 0.4.24 only It is recommended to follow the latter example, as future compiler versions may handle certain language constructions in a way the developer did not foresee. |
|   20 |   SOLIDITY_PRIVATE_MODIFIER_DOES_NOT_HIDE_DATA |Contrary to a popular misconception,the private code  modifier does not make a variable invisible. Miners have access to all contracts code and data. Developers must account for the lack of privacy in Ethereum.                                             |
|  21   | SOLIDITY_REDUNDANT_FALLBACK_REJECT | The payment rejection fallback is redundant.Contracts should reject unexpected payments. Before Solidity 0.4.0, it was done manually: Starting from Solidity 0.4.0, contracts without a fallback function automatically,revert payme.|                           
|   22  |  SOLIDITY_REVERT_REQUIRE | Using the construction code if (condition) {revert();} code instead of code require(condition)                     |
|  23   | SOLIDITY_REWRITE_ON_ASSEMBLY_CALL| Dangerous use of inline assembly instruction of code CALL family, which overwrites the input with the output.In case the arbitrary address is called return value may differ from expected one.                                             |
| 24    |    SOLIDITY_SAFEMATH  |   SafeMath library is used |
|  25   |   SOLIDITY_SEND                |  The function is called inside checks instead of using code transfer.The recommended way to perform checked ether payments is addr.transfer(x), which automatically throws an exception if the transfer is unsuccessful.                          |
|  26   |  SOLIDITY_SHOULD_NOT_BE_PURE   | In Solidity, function that do not read from the state or modify it can be declared as pure                                            |
| 27    |  SOLIDITY_SHOULD_NOT_BE_VIEW    |In Solidity,functions that do not read from the state or modify it can be declared as view.                                      |
|  28   |  SOLIDITY_SHOULD_RETURN_STRUCT  | Consider using struct instead of multiple return values for internal or private functions. It can improve code readability|
| 29 |      SOLIDITY_TRANSFER_IN_LOOP   | ETH is transferred in a loop. If at least one address cannot receive ETH (e.g. it is a contract with default fallback function), the whole transaction will be reverted.                                          |
|  30   |     SOLIDITY_TX_ORIGIN        | tx.origin is used for authorization.                                         |
|  31    | SOLIDITY_UINT_CANT_BE_NEGATIVE | Variables of uint type cannot be negative. Thus, comparing uint  variable with zero (greater than or equal) is redundant. Also, it may lead to an underflow issue. Moreover, comparison with zero used in for-loop condition results in an infinite loop.|
|  32   | SOLIDITY_UNCHECKED_CALL |  Expect calls to external contract to fail. When sending ether, check for the return value and handle errors. The recommended way of doing ether transfer is transfer code .                                       |
|  33   |   SOLIDITY_UNUSED_FUNCTION_SHOULD_BE_EXTERNAL | A function with public visibility modifier that is not called internally. Changing visibility level to external increases code readability. Moreover, in many cases functions with external visibility modifier spend less gas comparing to functions with public visibility modifier.|
|  34   |  SOLIDITY_UPGRADE_TO_050 |      Prepare your code for Solidity 0.5.0 release                                           |
|   35  |   SOLIDITY_USING_INLINE_ASSEMBLY|Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This discards several important safety features of Solidity.|
|  36 | SOLIDITY_VAR  |Solidity supports type inference:the type of i in code var i = 42;  is the smallest integer type sufficient to store the right-hand side value (uint8). Consider a common for-loop pattern:The type of i is inferred to uint8 . If array.length is bigger than 255, an overflow will occur. Explicitly define the type when declaring integer variables |
|  37    | SOLIDITY_VAR_IN_LOOP_FOR |Solidity supports type inference: the type of i in var i = 42; is the smallest integer type sufficient to store the right-hand side value (uint8). Consider a common for-loop pattern:The type of i is inferred to uint8. If array.length is bigger than 255, anoverflow will occur.|
| 39    | SOLIDITY_VISIBILITY | The default function visibility level in contracts is public , in interfaces - external , state variable default visibility level is internal. In contracts, the fallback function can be external or public . In interfaces, all the functions should be declared as external.Explicitly define function visibility to prevent confusion.|
| 40    |  SOLIDITY_WRONG_SIGNATURE | In Solidity, the function signature is defined as the canonical expression of the basic prototype without data location specifier, i.e. the function name with the parenthesised list of parameter types. Parameter types are split by a single comma - no spaces are used. This means one should use uint256 and int256 instead of int  or int.                                  |
